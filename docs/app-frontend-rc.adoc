// JBoss, Home of Professional Open Source
// Copyright 2016, Red Hat, Inc. and/or its affiliates, and individual
// contributors by the @authors tag. See the copyright.txt in the
// distribution for a full listing of individual contributors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

### Deploy frontend
Duration: 5:00

A Kubernetes pod is a group of containers, tied together for the purposes of administration and networking. It can contain one or more containers.  All containers within a single pod will share the same networking interface, IP address, volumes, etc.  All containers within the same pod instance will live and die together.  It’s especially useful when you have, for example, a container that runs the application, and another container that periodically polls logs/metrics from the application container.

You can start a single Pod in Kubernetes by creating a Pod resource. However, a Pod created this way would be known as a link:http://kubernetes.io/docs/user-guide/config-best-practices/[Naked Pod]. However, if a Naked Pod dies/exits, it will not be restarted by Kubernetes. A better way to start a pod, is by using a higher-level construct such as Replication Controller.

A Replication Controller ensures that a specified number of pod "replicas" are running. If there are too many pods, it will kill some. If there are too few, the replication controller will start more. Unlike manually created pods, the pods maintained by a replication controller are automatically replaced if they fail, get deleted, or are terminated.

Replication Controller is often abbreviated to “rc” in discussion, and as a shortcut in kubectl commands.

First create a Replication Controller using kubectl, the Kubernetes CLI tool:

[source, bash, subs="normal,attributes"]
----
[vagrant@rhel-cdk kubernetes]$ *kubectl create -f frontend-rc.yaml*
replicationcontroller "frontend-ui" created
----

You should see the frontend instances running:

[source, bash, subs="normal,attributes"]
----
[vagrant@rhel-cdk kubernetes]$ *kubectl get pods*
NAME                  READY     STATUS    RESTARTS   AGE
frontend-ui-?????     1/1       Running   0          2m
frontend-ui-?????     1/1       Running   0          2m
----

NOTE: The _ContainerCreating_ status means that Kubernetes still downloading the image from the registry before creating the containers.

#### Optional interlude: Look at your pod running in a Docker container on the VM

Kubernetes is container format agnostic. In your lab, we are working with Docker containers. Keep in mind that Kubernetes architecture allows it to work with other container formats too. You can see that the Docker container is running:


[source, bash, subs="normal,attributes"]
----
[vagrant@rhel-cdk kubernetes]$ *docker ps|grep microservices-frontend*
CONTAINER ID   IMAGE                                   COMMAND                 CREATED           STATUS            
52fb5e0aae73   rafabene/microservices-frontend:latest  "container-entrypoint"  14 minutes ago    Up 14 minutes     
....
----

